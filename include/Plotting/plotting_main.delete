#include <chrono>
#include <thread>
#if USE_ROOT_PLOTTING
#include "TApplication.h"
#endif
#include "scatter_plot_2D.hpp"
#include "scatter_plot_3D.hpp"
#include "series_plot_2D.hpp"
#include "time_plot_2D.hpp"
#include <cmath>
#include <vector>

struct sample
{
    float t;
    float x;
    float y;
};

int main()
{
    const auto          k = 10;
    std::vector<sample> v{};
    using sample_t = typename plotting::plots_2D::scatter_plot_2D::data_point;

    for (int i = 0; i != k; ++i)
    {
        v.push_back(sample{ float(i), float(i + 1) });
    }

    std::vector<float>                 x;
    std::vector<std::vector<float>>    y(2);
    std::vector<std::vector<sample_t>> data(2);

    for (auto const& e : v)
    {
        x.push_back(e.t);
        y[0].push_back(e.x);
        y[1].push_back(e.y);
        data[0].push_back({ e.x, e.y * e.y });
        data[1].push_back({ e.x, e.y * e.y });
    }


#ifdef USE_ROOT_PLOTTING
    TApplication app = TApplication("Root app", 0, nullptr);
#endif

    // plotting::plots_2D::series_plot_2D p(x, y);
    // p.render();

    plotting::plots_2D::scatter_plot_2D s(data);

    // plotting::plots_2D::time_plot_2D tp(2);
    std::vector<float> tmp(2);

    for (auto i = 0uz; i != 100; ++i)
    {
        for (auto j = 0uz; j != v.size(); ++j)
        {
            auto const& e = v[j];
            data[0][j]    = { std::sin(float(i + j)), float(j) };
            data[1][j]    = { std::cos(float(i + j)), float(j) };
        }
        s.render();
        if (i < y[0].size())
        {
            tmp[0] = y[0][i];
            tmp[1] = y[1][i];
            // tp.append(float(i) * 1.1f, tmp);
            // tp.render();
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(30));
    }


#ifdef USE_ROOT_PLOTTING
    app.Run();
#endif

    return 0;
}
